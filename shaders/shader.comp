#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D storageImage;

layout(binding = 1) uniform CameraUBO 
{
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
    bool relativistic_view_enabled; 
} cam;

struct Ray 
{
    vec3 origin;
    vec3 direction;
}; 

struct HitResult 
{
    bool didHit;
    float dst;
    vec3 color;
};
 
const float G_REAL = 6.67430e-11;
const float C_REAL = 299792458.0;
const float SOLAR_MASS = 1.989e30;
const float MASS = 10.0 * SOLAR_MASS;
 
const float RS_KM = (2.0 * G_REAL * MASS) / (C_REAL * C_REAL) / 1000.0; 

const int MAX_STEPS = 1000;
const float STEP_SIZE = 1.0; 

const vec3 SPHERE_POS = vec3(0.0, 0.0, -150.0); 
const float SPHERE_RADIUS = RS_KM;
const vec3 RING_NORMAL = normalize(vec3(0.3, 1.0, 0.3));
const float RING_INNER = RS_KM * 2.0; 
const float RING_OUTER = RS_KM * 5.0; 

bool hit_sphere(vec3 center, float radius, Ray ray, out float t_hit)
{
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant >= 0.0) { 
        t_hit = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t_hit < 0.0) t_hit = (-b + sqrt(discriminant)) / (2.0 * a);
        return t_hit >= 0.0;
    }
    return false;
}

bool intersect_plane(vec3 n, vec3 p0, Ray ray, out float t)
{
    float denom = dot(n, ray.direction);
    if (abs(denom) > 1e-6) 
    {
        vec3 p0l0 = p0 - ray.origin;
        t = dot(p0l0, n) / denom; 
        return (t >= 0.0);
    }
    return false;
}

bool hit_ring(vec3 center, vec3 normal, float inner_radius, float outer_radius, Ray ray, out float t_hit)
{
    if (intersect_plane(normal, center, ray, t_hit)) 
    {
        vec3 p = ray.origin + ray.direction * t_hit;
        vec3 v = p - center;
        float d2 = dot(v, v);
        return (d2 <= outer_radius * outer_radius && d2 >= inner_radius * inner_radius);
    }
    return false;
}

HitResult calculate_ray_collision(Ray r) 
{
    HitResult closestHit;
    closestHit.didHit = false;
    closestHit.dst = 1e10; 

    float t_sphere = 1e10;
    float t_ring = 1e10;
     
    if (hit_sphere(SPHERE_POS, SPHERE_RADIUS, r, t_sphere)) {
        if (t_sphere < closestHit.dst) {
            closestHit.didHit = true;
            closestHit.dst = t_sphere;
            closestHit.color = vec3(0.0, 0.0, 0.0); 
            if (!cam.relativistic_view_enabled) closestHit.color = vec3(0.74, 0.74, 0.74); 
        }
    }
     
    if (hit_ring(SPHERE_POS, RING_NORMAL, RING_INNER, RING_OUTER, r, t_ring)) {
        if (t_ring < closestHit.dst) {
            closestHit.didHit = true;
            closestHit.dst = t_ring;
            closestHit.color = vec3(1.0, 1.0, 1.0); 
        }
    }

    return closestHit;
}

vec3 get_sky_color(vec3 direction) {
    vec3 unit_direction = normalize(direction);
    float t = 0.5 * (unit_direction.y + 1.0);
    float f = 0.5 * (unit_direction.x + 1.0);
    return mix(vec3(f, 0.0, 0.65), vec3(f, 0.65, 0.0), t); 
} 

void main() 
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(storageImage);

    if (pixel_coords.x >= screen_size.x || pixel_coords.y >= screen_size.y) return;
    
    float u = float(pixel_coords.x) / float(screen_size.x - 1);
    float v = float(pixel_coords.y) / float(screen_size.y - 1);
     
    Ray r;
    r.origin = cam.origin;
    r.direction = normalize(cam.lower_left_corner + (u * cam.horizontal) + (v * cam.vertical) - cam.origin);

    vec3 finalColor = vec3(0.0);
     
    if (!cam.relativistic_view_enabled) 
    {
        HitResult hit = calculate_ray_collision(r);
        if (hit.didHit) finalColor = hit.color;
        else finalColor = get_sky_color(r.direction);
    } 
    else 
    {
        Ray curvedRay = r;
        bool hitSomething = false;

        for (int step = 0; step < MAX_STEPS; step++)
        { 
            HitResult hitInfo = calculate_ray_collision(curvedRay);
             
            if (hitInfo.didHit && hitInfo.dst <= STEP_SIZE)
            {
                finalColor = hitInfo.color;
                hitSomething = true;
                break; 
            }
             
            vec3 toSphere = SPHERE_POS - curvedRay.origin;
            float dist = length(toSphere);
             
            if (dist < SPHERE_RADIUS) {
                finalColor = vec3(0.0, 0.0, 0.0);
                hitSomething = true;
                break;
            }
             
            vec3 directionToSphere = toSphere / dist;
            float deflection = (2.0 * RS_KM) / (dist * dist); 
            
            curvedRay.direction = normalize(curvedRay.direction + directionToSphere * deflection * STEP_SIZE);
            curvedRay.origin += curvedRay.direction * STEP_SIZE;
             
            if (length(curvedRay.origin - cam.origin) > 1000.0) break;
        }

        if (!hitSomething) {
            finalColor = get_sky_color(curvedRay.direction);
        }
    } 

    vec2 distFromCenter = vec2(pixel_coords.x - screen_size.x / 2.0, pixel_coords.y - screen_size.y / 2.0);

    float vignette_radius = 10;

    float maxDist = length(vec2(screen_size) / 2.0);
    float vignette = 1.0 - (length(distFromCenter) / (maxDist * vignette_radius));
    vignette = clamp(vignette, 0.0, 1.0);

    finalColor *= vignette;

    imageStore(storageImage, pixel_coords, vec4(finalColor, vignette));
}