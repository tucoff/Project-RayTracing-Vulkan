#version 450
layout(local_size_x = 16, local_size_y = 16) in;
 
layout(binding = 0, rgba8) uniform writeonly image2D storageImage;
 
layout(binding = 1) uniform CameraUBO 
{
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
    bool relativistic_view_enabled;
} cam;

struct Ray 
{
    vec3 origin;
    vec3 direction;
}; 

bool hit_sphere(vec3 center, float radius, Ray ray, out float t_hit)
{
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant >= 0.0) { 
        t_hit = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t_hit < 0.0) t_hit = (-b + sqrt(discriminant)) / (2.0 * a);
        return t_hit >= 0.0;
    }
    return false;
}
 
bool intersect_plane(vec3 n, vec3 p0, Ray ray, out float t)
{
    float denom = dot(n, ray.direction);
     
    if (abs(denom) > 1e-6) 
    {
        vec3 p0l0 = p0 - ray.origin;
        t = dot(p0l0, n) / denom; 
        return (t >= 0.0);
    }

    return false;
}
 
bool hit_ring(vec3 center, vec3 normal, float inner_radius, float outer_radius, Ray ray, out float t_hit)
{
    if (intersect_plane(normal, center, ray, t_hit)) 
    {
        vec3 p = ray.origin + ray.direction * t_hit;
        vec3 v = p - center;
        float d2 = dot(v, v);
         
        return (d2 <= outer_radius * outer_radius && d2 >= inner_radius * inner_radius);
    }

    return false;
}
 
vec3 ray_color(Ray r) 
{ 
    vec3 sphereCenter = vec3(0.0, 0.0, -1.0);
    float sphereRadius = 0.5;
     
    vec3 ringNormal = normalize(vec3(0.3, 1.0, 0.3)); 
    float ringInnerRadius = sphereRadius * 1.2; 
    float ringOuterRadius = sphereRadius * 2.0; 
     
    float t_sphere = 10000.0;
    float t_ring = 10000.0;
    bool hitS = hit_sphere(sphereCenter, sphereRadius, r, t_sphere);
    bool hitR = hit_ring(sphereCenter, ringNormal, ringInnerRadius, ringOuterRadius, r, t_ring);
     
    if (hitS && hitR) 
    {
        if (t_sphere < t_ring) hitR = false; 
        else hitS = false;  
    }

    if (hitS && !cam.relativistic_view_enabled) return vec3(0.0, 1.0, 0.0);
    else if (hitS) return vec3(1.0, 0.0, 0.0);
    if (hitR) return vec3(0.0, 0.0, 1.0);  
     
    vec3 unit_direction = normalize(r.direction);
    float t = 0.5 * (unit_direction.y + 1.0);
    return mix(vec3(0.5, 0.7, 1.0), vec3(0.0, 0.0, 0.0), t);
}

void main() 
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(storageImage);

    if (pixel_coords.x >= screen_size.x || pixel_coords.y >= screen_size.y) return;
     
    float u = float(pixel_coords.x) / float(screen_size.x - 1);
    float v = float(pixel_coords.y) / float(screen_size.y - 1);
     
    Ray r;
    r.origin = cam.origin;
    r.direction = cam.lower_left_corner + (u * cam.horizontal) + (v * cam.vertical) - cam.origin;

    vec3 pixel_color = ray_color(r);

    imageStore(storageImage, pixel_coords, vec4(pixel_color, 1.0));
}